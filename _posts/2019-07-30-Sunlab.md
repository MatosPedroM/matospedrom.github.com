---
layout: post
title: "EDP Open Data SunPower Prediction"
categories: forecast
---

## EDP Open Data SunPower Prediction Competition


The [objective](https://opendata.edp.com/pages/challenges/) of this competition is to build an algorithm that predicts the **production of solar module B (with optimal orientation) for the first seven days of 2018.** For this, you can rely on the weather station data for these days 

### Sublab

[Sunlab](https://opendata.edp.com/pages/Sunlab/) is a photovoltaic on-field laboratoy whose main objective is to supports **[EDP](http://www.edp.com)'**s business units on the acquisition of knowledge in the solar marketfield. The project has been covering the following topics:

* Performance and reliability analysis of conventional PV technologies;
* Demonstration of new technologies and evaluation of its potential to integrate EDP’s portofolio;
* Optimization and identification of new approaches regarding O&M challenges;
* Provide a strong database crucial for the development of analytic tools (e.g. forecasting models).

Sunlab laboratories are scattered throughout mainland Portugal, in which photovoltaic panels using different technologies have been installed. This way, we can characterize the performance of each technology under different climatic conditions.

SunLab has been in operation since 2012.

---

In this notebook we will implement an forecast model for the PV e Meteo dataset provedied in order to forecast the model B PV generation

Let's start by loading the usual packages


```python
import warnings 
warnings.filterwarnings(action='ignore')

from pandas import read_csv
import pandas as pd
import numpy as np
from matplotlib import pyplot
%matplotlib inline

import prettytable as pt

import seaborn as sns
sns.set(style='white', palette='deep', font_scale=1.25, font='calibri')

#from IPython.display import set_matplotlib_formats
#set_matplotlib_formats('pdf', 'png')
#pyplot.rcParams['savefig.dpi'] = 75

pyplot.rcdefaults() 

#pyplot.rcParams['figure.autolayout'] = False
pyplot.rcParams['figure.figsize'] = 10, 7
pyplot.rcParams['axes.labelsize'] = 10
pyplot.rcParams['axes.titlesize'] = 12
pyplot.rcParams['font.size'] = 10
pyplot.rcParams['lines.linewidth'] = 1.5
pyplot.rcParams['lines.markersize'] = 8
pyplot.rcParams['legend.fontsize'] = 10
#pyplot.rcParams['text.usetex'] = True
#pyplot.rcParams['font.serif'] = "cm"
#plt.rcParams['text.latex.preamble'] = "\usepackage{subdepth}, \usepackage{type1cm}"


```

The dataset consisits of two sets of datafiles with readings for several years (2014-2018):
* Weather station data
* PV's modules generation and temperature data

The granularity of the data is one minute and the timezone is UTC (Coordinated Universal Time) and all files have daylight saving time correction.

As we will be forecasting the power generation for 2018 we will load everything else (2014-2017).

## Reading weather station data

Haveing to read several file we will batch-reading using **iglob**


```python
from glob import iglob

path = r'sunlab-faro-meteo-*.csv'
all_rec = iglob(path, recursive=True)     
batch = (pd.read_csv(f, sep =";", decimal='.',index_col=0, parse_dates=True, low_memory=True, dayfirst= True) for f in all_rec)

meteo_data = pd.concat(batch)
#sort the index
meteo_data.sort_index(inplace=True)

print('Total lines:', len(meteo_data)) 
print(meteo_data.count())

```

    Total lines: 1886656
    Ambient Temperature [ºC]      1886656
    Atmospheric pressure [hPa]     585633
    Diffuse Radiation [W/m2]      1486912
    Direct Radiation [W/m2]        399744
    Global Radiation [W/m2]       1886656
    Precipitation [mm]             585633
    Ultraviolet [W/m2]            1886656
    Wind Direction [º]            1886656
    Wind Velocity [m/s]           1886656
    dtype: int64
    

Comparing the counts we can see that the full dataset as ~1.8M registers but some 'channels' have lot less information (Atmospheric pressure, Direct Radiation and Precipitation)

Let's see the general stats of the dataset


```python
meteo_data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Atmospheric pressure [hPa]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Direct Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Precipitation [mm]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2014-01-01 00:00:00</th>
      <td>15.300000</td>
      <td>NaN</td>
      <td>1.649239</td>
      <td>NaN</td>
      <td>1.406050</td>
      <td>NaN</td>
      <td>0.508442</td>
      <td>232.00156</td>
      <td>2.300000</td>
    </tr>
    <tr>
      <th>2014-01-01 00:01:00</th>
      <td>15.300000</td>
      <td>NaN</td>
      <td>1.645474</td>
      <td>NaN</td>
      <td>1.365813</td>
      <td>NaN</td>
      <td>0.507736</td>
      <td>227.50672</td>
      <td>2.416667</td>
    </tr>
    <tr>
      <th>2014-01-01 00:02:00</th>
      <td>15.283334</td>
      <td>NaN</td>
      <td>1.649413</td>
      <td>NaN</td>
      <td>1.406155</td>
      <td>NaN</td>
      <td>0.508740</td>
      <td>219.86790</td>
      <td>2.500000</td>
    </tr>
    <tr>
      <th>2014-01-01 00:03:00</th>
      <td>15.300000</td>
      <td>NaN</td>
      <td>1.645420</td>
      <td>NaN</td>
      <td>1.293696</td>
      <td>NaN</td>
      <td>0.508438</td>
      <td>222.98490</td>
      <td>2.850000</td>
    </tr>
    <tr>
      <th>2014-01-01 00:04:00</th>
      <td>15.300000</td>
      <td>NaN</td>
      <td>1.645991</td>
      <td>NaN</td>
      <td>1.474050</td>
      <td>NaN</td>
      <td>0.508635</td>
      <td>228.94006</td>
      <td>2.500000</td>
    </tr>
  </tbody>
</table>
</div>




```python
meteo_data.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Atmospheric pressure [hPa]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Direct Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Precipitation [mm]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1.886656e+06</td>
      <td>5.856330e+05</td>
      <td>1.486912e+06</td>
      <td>399744.000000</td>
      <td>1.886656e+06</td>
      <td>585633.00000</td>
      <td>1.886656e+06</td>
      <td>1.886656e+06</td>
      <td>1.886656e+06</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>-7.136860e+03</td>
      <td>-4.106221e+03</td>
      <td>6.474817e+01</td>
      <td>63.948456</td>
      <td>2.312152e+02</td>
      <td>0.00087</td>
      <td>1.419916e+01</td>
      <td>2.142176e+02</td>
      <td>-7.153373e+03</td>
    </tr>
    <tr>
      <th>std</th>
      <td>3.276161e+06</td>
      <td>2.771999e+06</td>
      <td>9.466603e+01</td>
      <td>96.749847</td>
      <td>3.182966e+02</td>
      <td>0.01856</td>
      <td>1.923120e+01</td>
      <td>9.881624e+01</td>
      <td>3.276161e+06</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-1.500000e+09</td>
      <td>-1.499999e+09</td>
      <td>1.564069e+00</td>
      <td>1.574275</td>
      <td>7.284710e-01</td>
      <td>0.00000</td>
      <td>4.954330e-01</td>
      <td>0.000000e+00</td>
      <td>-1.500000e+09</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.440000e+01</td>
      <td>1.012700e+03</td>
      <td>1.690771e+00</td>
      <td>1.687485</td>
      <td>1.565097e+00</td>
      <td>0.00000</td>
      <td>5.105560e-01</td>
      <td>1.241708e+02</td>
      <td>1.116667e+00</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.840000e+01</td>
      <td>1.015700e+03</td>
      <td>9.936894e+00</td>
      <td>8.564234</td>
      <td>1.011498e+01</td>
      <td>0.00000</td>
      <td>1.251254e+00</td>
      <td>2.375354e+02</td>
      <td>1.983333e+00</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2.290000e+01</td>
      <td>1.019700e+03</td>
      <td>9.803525e+01</td>
      <td>91.860982</td>
      <td>4.376783e+02</td>
      <td>0.00000</td>
      <td>2.519825e+01</td>
      <td>2.983271e+02</td>
      <td>2.933334e+00</td>
    </tr>
    <tr>
      <th>max</th>
      <td>3.830000e+01</td>
      <td>1.035900e+03</td>
      <td>7.765521e+02</td>
      <td>790.061200</td>
      <td>1.484380e+03</td>
      <td>2.04000</td>
      <td>8.551538e+01</td>
      <td>3.600000e+02</td>
      <td>1.501667e+01</td>
    </tr>
  </tbody>
</table>
</div>



We can see that there is some 'strange' very low negatives in the Ambient Temperature, Atmospheric pressure and Wind Velocity 

Also, we can see that some channels have a lot more information the others, namely Atmospheric Pressure, Difuse and Direct Radiation and Precipitation.


```python
#% of total registers
meteo_data.count()/len(meteo_data)*100
```




    Ambient Temperature [ºC]      100.000000
    Atmospheric pressure [hPa]     31.040794
    Diffuse Radiation [W/m2]       78.812036
    Direct Radiation [W/m2]        21.187964
    Global Radiation [W/m2]       100.000000
    Precipitation [mm]             31.040794
    Ultraviolet [W/m2]            100.000000
    Wind Direction [º]            100.000000
    Wind Velocity [m/s]           100.000000
    dtype: float64



For a quick visual inspection lets plot all the channels. 

Let's create a function because we'll suerly use it several times...


```python
def plot_channels (dataset):
    n_channels = len(dataset.columns)
    max_range = len(dataset)
    pyplot.figure(figsize=(20,10))
    for i in range (n_channels):
        pyplot.subplot(n_channels, 1, i+1)
        pyplot.title(dataset.columns[i], y=1)
        pyplot.plot(dataset.iloc[0:max_range,i])
        pyplot.grid()
        pyplot.tight_layout()
    pyplot.show()
```


```python
plot_channels(meteo_data)
```


![png](/assets/2019-07-30-Sunlab/output_11_0.png)


We a draw a couple of conclusions of this plots:
  1. There are a couple of very negative values for Ambient Temperature, Atmospheric Pressure and Wind Velocity;
  * There are no readings of Difuse Radiation in 2016;
  * We only have Atmospheric Pressure, Direct Radiation and Precipitation readings after 2016 and considerable gaps
  * UV, Global Radiation and Wind Direction present considerable gaps in 2016

Drawing a course of action to adress the problems above we will:
 * Remove 2016 from the data set,
 * Discard Atmospheric Pressure, Direct Radiation and Precipitation from the dataset, and
 * Replace the outliers of Ambient Temperature and Wind Velocity



```python
#Remove 2016 from the data set
import datetime
meteo_data = meteo_data[(meteo_data.index < datetime.datetime(2016,1,1)) | (meteo_data.index > datetime.datetime(2016,12,31))]
meteo_data.sort_index(inplace= True)

#Discard Atmospheric Pressure, Direct Radiation and Precipitation from the dataset
meteo_data.drop(columns=['Atmospheric pressure [hPa]','Direct Radiation [W/m2]','Precipitation [mm]'], inplace=True)
meteo_data.sort_index(inplace= True)

```


```python
#Replace the outliers of Ambient Temperature and Wind Velocity
def replace_outliers_mean(dataset, columns, threshold):
    for col in columns:
        print ('Fixing', col)
        i = 0
        while  dataset[col].min() < threshold:
            aux = dataset[col].min()
            indx = np.where(dataset[col] == aux)[0][0]
            avr = (dataset[col].iloc[indx-1] + dataset[col].iloc[indx+1])/2
            dataset[col].iloc[indx] = avr
            i = i + 1
        print('Fixed', i, 'values')
        
replace_outliers_mean(meteo_data, ['Ambient Temperature [ºC]','Wind Velocity [m/s]']  , -1)
```

    Fixing Ambient Temperature [ºC]
    Fixed 8 values
    Fixing Wind Velocity [m/s]
    Fixed 8 values
    

So let's examine the cleaned dataset again


```python
meteo_data.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1.488292e+06</td>
      <td>1.486912e+06</td>
      <td>1.488292e+06</td>
      <td>1.488292e+06</td>
      <td>1.488292e+06</td>
      <td>1.488292e+06</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1.870219e+01</td>
      <td>6.474817e+01</td>
      <td>2.317793e+02</td>
      <td>1.420853e+01</td>
      <td>2.147273e+02</td>
      <td>2.125156e+00</td>
    </tr>
    <tr>
      <th>std</th>
      <td>5.735285e+00</td>
      <td>9.466603e+01</td>
      <td>3.185582e+02</td>
      <td>1.921217e+01</td>
      <td>9.834946e+01</td>
      <td>1.283511e+00</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.700000e+00</td>
      <td>1.564069e+00</td>
      <td>7.300290e-01</td>
      <td>4.954330e-01</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.456667e+01</td>
      <td>1.690771e+00</td>
      <td>1.565481e+00</td>
      <td>5.105640e-01</td>
      <td>1.256893e+02</td>
      <td>1.100000e+00</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.870000e+01</td>
      <td>9.936894e+00</td>
      <td>1.038539e+01</td>
      <td>1.275082e+00</td>
      <td>2.379971e+02</td>
      <td>1.950000e+00</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2.281667e+01</td>
      <td>9.803525e+01</td>
      <td>4.398197e+02</td>
      <td>2.531724e+01</td>
      <td>2.977952e+02</td>
      <td>2.916667e+00</td>
    </tr>
    <tr>
      <th>max</th>
      <td>3.790000e+01</td>
      <td>7.765521e+02</td>
      <td>1.484380e+03</td>
      <td>8.551538e+01</td>
      <td>3.600000e+02</td>
      <td>1.501667e+01</td>
    </tr>
  </tbody>
</table>
</div>




```python
#NaN count
len(meteo_data) - meteo_data.count()
```




    Ambient Temperature [ºC]       0
    Diffuse Radiation [W/m2]    1380
    Global Radiation [W/m2]        0
    Ultraviolet [W/m2]             0
    Wind Direction [º]             0
    Wind Velocity [m/s]            0
    dtype: int64



Look's like there are some NaN to handle so we will look for them and try to sort them out


```python
difuse_rad_nan = meteo_data[meteo_data['Diffuse Radiation [W/m2]'].isna()]
difuse_rad_nan.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2016-12-31 00:01:00</th>
      <td>9.6</td>
      <td>NaN</td>
      <td>1.452291</td>
      <td>0.502689</td>
      <td>19.268750</td>
      <td>1.700000</td>
    </tr>
    <tr>
      <th>2016-12-31 00:02:00</th>
      <td>9.6</td>
      <td>NaN</td>
      <td>1.569286</td>
      <td>0.502589</td>
      <td>294.363120</td>
      <td>1.433333</td>
    </tr>
    <tr>
      <th>2016-12-31 00:03:00</th>
      <td>9.6</td>
      <td>NaN</td>
      <td>1.264598</td>
      <td>0.503593</td>
      <td>3.183061</td>
      <td>1.616667</td>
    </tr>
    <tr>
      <th>2016-12-31 00:04:00</th>
      <td>9.6</td>
      <td>NaN</td>
      <td>1.276142</td>
      <td>0.504798</td>
      <td>34.756704</td>
      <td>1.266667</td>
    </tr>
    <tr>
      <th>2016-12-31 00:05:00</th>
      <td>9.6</td>
      <td>NaN</td>
      <td>1.154667</td>
      <td>0.506697</td>
      <td>54.950868</td>
      <td>1.133333</td>
    </tr>
  </tbody>
</table>
</div>




```python
difuse_rad_nan.tail()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2016-12-31 22:56:00</th>
      <td>11.200000</td>
      <td>NaN</td>
      <td>2.102965</td>
      <td>0.509100</td>
      <td>62.577372</td>
      <td>1.666667</td>
    </tr>
    <tr>
      <th>2016-12-31 22:57:00</th>
      <td>11.233334</td>
      <td>NaN</td>
      <td>1.560519</td>
      <td>0.508898</td>
      <td>59.805536</td>
      <td>1.783333</td>
    </tr>
    <tr>
      <th>2016-12-31 22:58:00</th>
      <td>11.300000</td>
      <td>NaN</td>
      <td>1.839297</td>
      <td>0.508201</td>
      <td>58.696268</td>
      <td>1.783333</td>
    </tr>
    <tr>
      <th>2016-12-31 22:59:00</th>
      <td>11.300000</td>
      <td>NaN</td>
      <td>1.756216</td>
      <td>0.507706</td>
      <td>52.142492</td>
      <td>1.633333</td>
    </tr>
    <tr>
      <th>2016-12-31 23:00:00</th>
      <td>11.300000</td>
      <td>NaN</td>
      <td>1.640478</td>
      <td>0.506991</td>
      <td>59.050408</td>
      <td>1.666667</td>
    </tr>
  </tbody>
</table>
</div>




```python
#to be sure will check if there are more days
np.unique(difuse_rad_nan.index.date)
```




    array([datetime.date(2016, 12, 31)], dtype=object)




```python
#finaly, removing NaN rows
meteo_data.dropna(inplace=True)
meteo_data.sort_index(inplace= True)

#... and the final check
meteo_data.count()
```




    Ambient Temperature [ºC]    1486912
    Diffuse Radiation [W/m2]    1486912
    Global Radiation [W/m2]     1486912
    Ultraviolet [W/m2]          1486912
    Wind Direction [º]          1486912
    Wind Velocity [m/s]         1486912
    dtype: int64




```python
#Plot entire week of Meteo dataset
plot_channels(meteo_data[0:7*24*60])
```


![png](/assets/2019-07-30-Sunlab/output_23_0.png)


Now that we've sorted all the NaN let's add a function to see the histograms of all the channels


```python
def dist_channels (dataset):
    n_channels = len(dataset.columns)
    max_range = len(dataset)
    pyplot.figure(figsize=(20,10))
    for i in range (n_channels):
        pyplot.subplot(n_channels, 1, i+1)
        pyplot.title(dataset.columns[i], y=1)
        pyplot.hist(dataset.iloc[0:max_range,i], bins= 100)
        pyplot.grid()
        pyplot.tight_layout()
    pyplot.show()
```


```python
dist_channels(meteo_data)
```


![png](/assets/2019-07-30-Sunlab/output_26_0.png)


Everything looks normal so let's advance to the PV dataset...

### Reading PV data

We will procede the same way as with the weather data station


```python
path = r'sunlab-faro-pv-*.csv'
all_rec = iglob(path, recursive=True)     
batch = (pd.read_csv(f, sep =";", decimal='.',index_col=0, parse_dates=True, low_memory=True) for f in all_rec)

pv_data = pd.concat(batch)
#sort the index
pv_data.sort_index(inplace=True)

print('Total lines:', len(pv_data)) 
print(pv_data.count())
```

    Total lines: 889611
    A_Vertical - Voltage DC [V]        864055
    A_Vertical - Current DC [A]        864055
    A_Vertical - Power DC [W]          864055
    A_Optimal - Voltage DC [V]         875353
    A_Optimal - Current DC [A]         875353
    A_Optimal - Power DC [W]           875353
    A_Horizontal - Voltage DC [V]      873826
    A_Horizontal - Current DC [A]      873826
    A_Horizontal - Power DC [W]        873826
    A_Vertical - Temperature [ºC]      889611
    A_Optimal - Temperature [ºC]       889611
    A_Horizontal - Temperature [ºC]    889611
    B_Vertical - Voltage DC [V]        869138
    B_Vertical - Current DC [A]        869138
    B_Vertical - Power DC [W]          869138
    B_Optimal - Voltage DC [V]         876065
    B_Optimal - Current DC [A]         876065
    B_Optimal - Power DC [W]           876065
    B_Horizontal - Voltage DC [V]      868127
    B_Horizontal - Current DC [A]      868127
    B_Horizontal - Power DC [W]        868127
    B_Vertical - Temperature [ºC]      889611
    B_Optimal - Temperature [ºC]       889611
    B_Horizontal - Temperature [ºC]    889611
    dtype: int64
    

For the loaded files we can see that:
* There are mesurements for several panels
* All the channels have generaly the same length

As are what to forecast the PV generation of panel **B Optimal** let's just discard mesurements for the rest


```python
#get the columns that contain B_Optimal
pv_b_optimal_columns = pv_data.columns[pv_data.columns.str.contains('B_Optimal')]
#create a new dataframe with the above columns
pv_b_optimal_data = pv_data[pv_b_optimal_columns]
pv_b_optimal_data.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B_Optimal - Voltage DC [V]</th>
      <th>B_Optimal - Current DC [A]</th>
      <th>B_Optimal - Power DC [W]</th>
      <th>B_Optimal - Temperature [ºC]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2014-01-01 07:41:00</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>9.7</td>
    </tr>
    <tr>
      <th>2014-01-01 07:42:00</th>
      <td>18.30</td>
      <td>0.130512</td>
      <td>2.388366</td>
      <td>9.7</td>
    </tr>
    <tr>
      <th>2014-01-01 07:43:00</th>
      <td>22.35</td>
      <td>0.052500</td>
      <td>1.173375</td>
      <td>9.7</td>
    </tr>
    <tr>
      <th>2014-01-01 07:44:00</th>
      <td>24.35</td>
      <td>0.052500</td>
      <td>1.278375</td>
      <td>9.7</td>
    </tr>
    <tr>
      <th>2014-01-01 07:45:00</th>
      <td>25.25</td>
      <td>0.052500</td>
      <td>1.325625</td>
      <td>9.7</td>
    </tr>
  </tbody>
</table>
</div>




```python
#Ploting an entire week of PV dataset ?
plot_channels(pv_b_optimal_data[0:7*24*60])
```


![png](/assets/2019-07-30-Sunlab/output_31_0.png)


It seams that the PV dataset doesn't have mesures for during the nigth... Let's take a closer look.


```python
#PV dataset mesurement from 1st to 2nd day
pv_b_optimal_data[560:580]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B_Optimal - Voltage DC [V]</th>
      <th>B_Optimal - Current DC [A]</th>
      <th>B_Optimal - Power DC [W]</th>
      <th>B_Optimal - Temperature [ºC]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2014-01-01 17:02:00</th>
      <td>28.75</td>
      <td>0.0125</td>
      <td>0.359375</td>
      <td>16.6</td>
    </tr>
    <tr>
      <th>2014-01-01 17:03:00</th>
      <td>28.60</td>
      <td>0.0125</td>
      <td>0.357500</td>
      <td>16.6</td>
    </tr>
    <tr>
      <th>2014-01-01 17:04:00</th>
      <td>19.85</td>
      <td>0.0575</td>
      <td>1.141375</td>
      <td>16.6</td>
    </tr>
    <tr>
      <th>2014-01-01 17:05:00</th>
      <td>28.00</td>
      <td>0.0125</td>
      <td>0.350000</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-01 17:06:00</th>
      <td>27.55</td>
      <td>0.0125</td>
      <td>0.344375</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-01 17:07:00</th>
      <td>26.85</td>
      <td>0.0125</td>
      <td>0.335625</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-01 17:08:00</th>
      <td>25.95</td>
      <td>0.0125</td>
      <td>0.324375</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-01 17:09:00</th>
      <td>24.85</td>
      <td>0.0125</td>
      <td>0.310625</td>
      <td>16.4</td>
    </tr>
    <tr>
      <th>2014-01-01 17:10:00</th>
      <td>23.65</td>
      <td>0.0125</td>
      <td>0.295625</td>
      <td>16.4</td>
    </tr>
    <tr>
      <th>2014-01-01 17:11:00</th>
      <td>22.20</td>
      <td>0.0150</td>
      <td>0.333000</td>
      <td>16.4</td>
    </tr>
    <tr>
      <th>2014-01-01 17:12:00</th>
      <td>15.15</td>
      <td>0.0175</td>
      <td>0.265125</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-01 17:13:00</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>16.5</td>
    </tr>
    <tr>
      <th>2014-01-02 08:11:00</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>17.7</td>
    </tr>
    <tr>
      <th>2014-01-02 08:12:00</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>17.7</td>
    </tr>
    <tr>
      <th>2014-01-02 08:13:00</th>
      <td>19.40</td>
      <td>0.0575</td>
      <td>1.115500</td>
      <td>17.7</td>
    </tr>
    <tr>
      <th>2014-01-02 08:14:00</th>
      <td>22.20</td>
      <td>0.0575</td>
      <td>1.276500</td>
      <td>17.7</td>
    </tr>
    <tr>
      <th>2014-01-02 08:15:00</th>
      <td>20.60</td>
      <td>0.0650</td>
      <td>1.339000</td>
      <td>17.8</td>
    </tr>
    <tr>
      <th>2014-01-02 08:16:00</th>
      <td>18.85</td>
      <td>0.0675</td>
      <td>1.272375</td>
      <td>17.8</td>
    </tr>
    <tr>
      <th>2014-01-02 08:17:00</th>
      <td>28.65</td>
      <td>0.0125</td>
      <td>0.358125</td>
      <td>17.8</td>
    </tr>
    <tr>
      <th>2014-01-02 08:18:00</th>
      <td>28.45</td>
      <td>0.0125</td>
      <td>0.355625</td>
      <td>17.8</td>
    </tr>
  </tbody>
</table>
</div>



This means that we will have to be carefull when mergin Meteo and PV datasets.
We will have to merged keeping all the records from Meto dataset and then fill in the PV missing values.

Let's also look at the big picture...


```python
plot_channels(pv_b_optimal_data)
```


![png](/assets/2019-07-30-Sunlab/output_35_0.png)


Once again we can see that there are problems with 2016 mesuresments but also with 2017 that have some gaps.

As we have removed 2016 from the weather station we will do the same thing for the PV data.

Knowing the weahter and PV data, at this point it makes sense the assume that **we will be using a regression model to forecast the PV generation** and so it's more important the instantaneus relation of the variables than the time sieres pattern, e.g. that the previous minute PV generation value "helps" to explain the next one.


```python
#remove 2016 from PV B Optimal dataset
pv_b_optimal_data = pv_b_optimal_data[(pv_b_optimal_data.index < datetime.datetime(2016,1,1)) | (pv_b_optimal_data.index > datetime.datetime(2016,12,31))]

#remove NaN
pv_b_optimal_data.dropna(inplace=True)
pv_b_optimal_data.sort_index(inplace= True)

pv_b_optimal_data.count()
```




    B_Optimal - Voltage DC [V]      701258
    B_Optimal - Current DC [A]      701258
    B_Optimal - Power DC [W]        701258
    B_Optimal - Temperature [ºC]    701258
    dtype: int64




```python
dist_channels(pv_b_optimal_data)
```


![png](/assets/2019-07-30-Sunlab/output_38_0.png)


## Merging Meteo and PV dataset

Now we will merge both weather and PV data frame and try to retain as much information as possible


```python
merged = pd.merge(left=meteo_data, right=pv_b_optimal_data, how='left', left_index=True,right_index=True)
merged.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
      <th>B_Optimal - Voltage DC [V]</th>
      <th>B_Optimal - Current DC [A]</th>
      <th>B_Optimal - Power DC [W]</th>
      <th>B_Optimal - Temperature [ºC]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2014-01-01 00:00:00</th>
      <td>15.300000</td>
      <td>1.649239</td>
      <td>1.406050</td>
      <td>0.508442</td>
      <td>232.00156</td>
      <td>2.300000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2014-01-01 00:01:00</th>
      <td>15.300000</td>
      <td>1.645474</td>
      <td>1.365813</td>
      <td>0.507736</td>
      <td>227.50672</td>
      <td>2.416667</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2014-01-01 00:02:00</th>
      <td>15.283334</td>
      <td>1.649413</td>
      <td>1.406155</td>
      <td>0.508740</td>
      <td>219.86790</td>
      <td>2.500000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2014-01-01 00:03:00</th>
      <td>15.300000</td>
      <td>1.645420</td>
      <td>1.293696</td>
      <td>0.508438</td>
      <td>222.98490</td>
      <td>2.850000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2014-01-01 00:04:00</th>
      <td>15.300000</td>
      <td>1.645991</td>
      <td>1.474050</td>
      <td>0.508635</td>
      <td>228.94006</td>
      <td>2.500000</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



There are a lot of NaN due to the left merge so we will have to filled them with something.
As they ocur during the night we will consider that all PV data, expect temperature, will be zero.

During the night we should fill the temperature of the PV with the Meteo dataset, but for simplification will we just disgard it from the PV dataset, as it should 'mirror' in a large extende the Meteo dataset Temperature chanell


```python
#removing B_Optimal - Temperature [ºC]
merged = merged.drop(columns='B_Optimal - Temperature [ºC]')
#fill NaN with zero
merged = merged.fillna(value=0, axis = 1)
```


```python
merged.describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
      <th>B_Optimal - Voltage DC [V]</th>
      <th>B_Optimal - Current DC [A]</th>
      <th>B_Optimal - Power DC [W]</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
      <td>1.486912e+06</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1.870792e+01</td>
      <td>6.474817e+01</td>
      <td>2.318649e+02</td>
      <td>1.421471e+01</td>
      <td>2.148486e+02</td>
      <td>2.125174e+00</td>
      <td>1.213334e+01</td>
      <td>1.668238e+00</td>
      <td>4.558327e+01</td>
    </tr>
    <tr>
      <th>std</th>
      <td>5.734571e+00</td>
      <td>9.466603e+01</td>
      <td>3.186344e+02</td>
      <td>1.921742e+01</td>
      <td>9.829691e+01</td>
      <td>1.283938e+00</td>
      <td>1.335602e+01</td>
      <td>2.547834e+00</td>
      <td>6.971338e+01</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.700000e+00</td>
      <td>1.564069e+00</td>
      <td>7.300290e-01</td>
      <td>4.954330e-01</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.460000e+01</td>
      <td>1.690771e+00</td>
      <td>1.565540e+00</td>
      <td>5.105690e-01</td>
      <td>1.259656e+02</td>
      <td>1.100000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.870000e+01</td>
      <td>9.936894e+00</td>
      <td>1.043143e+01</td>
      <td>1.278358e+00</td>
      <td>2.380426e+02</td>
      <td>1.950000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2.283333e+01</td>
      <td>9.803525e+01</td>
      <td>4.400026e+02</td>
      <td>2.533117e+01</td>
      <td>2.978268e+02</td>
      <td>2.916667e+00</td>
      <td>2.725000e+01</td>
      <td>2.882500e+00</td>
      <td>8.152350e+01</td>
    </tr>
    <tr>
      <th>max</th>
      <td>3.790000e+01</td>
      <td>7.765521e+02</td>
      <td>1.484380e+03</td>
      <td>8.551538e+01</td>
      <td>3.600000e+02</td>
      <td>1.501667e+01</td>
      <td>3.655000e+01</td>
      <td>1.023750e+01</td>
      <td>3.107081e+02</td>
    </tr>
  </tbody>
</table>
</div>




```python
#Correlation heat map
corr = merged.corr()
#mask to remove upper and 1 corrs
mask = np.zeros_like(corr); mask[np.triu_indices_from(mask)] = True
sns.heatmap(data = corr, annot=True, cmap='coolwarm', fmt='.3f', linewidths=1, mask=mask, )
pyplot.show()
```


![png](/assets/2019-07-30-Sunlab/output_45_0.png)


Conclustions from the correlation heatmap:   
* PV Power DC generation as a strong correlation with Global Radiation, UV and with Current DC (Power DC is the product of Current DC by Voltage DC).  
* Wind direction is the only variable with an (slightly) inverse correlation with PV Power DC
* UV and Global Radiation have a strong correlation, indicating the we could probably use just one of the variable for the forecast

As to forecat the PV generation for 2018 provided points we will only have the wheather data let's reduce the merged dataframe do the channels (*features*) that we will use to forecast and the PV Power DC (*label*)

Let's prepare the merged dataset to modeling


```python
final = merged.copy()
final.drop(columns=['B_Optimal - Voltage DC [V]', 'B_Optimal - Current DC [A]'], inplace=True)
final.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Ambient Temperature [ºC]</th>
      <th>Diffuse Radiation [W/m2]</th>
      <th>Global Radiation [W/m2]</th>
      <th>Ultraviolet [W/m2]</th>
      <th>Wind Direction [º]</th>
      <th>Wind Velocity [m/s]</th>
      <th>B_Optimal - Power DC [W]</th>
    </tr>
    <tr>
      <th>Datetime</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2014-01-01 00:00:00</th>
      <td>15.300000</td>
      <td>1.649239</td>
      <td>1.406050</td>
      <td>0.508442</td>
      <td>232.00156</td>
      <td>2.300000</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2014-01-01 00:01:00</th>
      <td>15.300000</td>
      <td>1.645474</td>
      <td>1.365813</td>
      <td>0.507736</td>
      <td>227.50672</td>
      <td>2.416667</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2014-01-01 00:02:00</th>
      <td>15.283334</td>
      <td>1.649413</td>
      <td>1.406155</td>
      <td>0.508740</td>
      <td>219.86790</td>
      <td>2.500000</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2014-01-01 00:03:00</th>
      <td>15.300000</td>
      <td>1.645420</td>
      <td>1.293696</td>
      <td>0.508438</td>
      <td>222.98490</td>
      <td>2.850000</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2014-01-01 00:04:00</th>
      <td>15.300000</td>
      <td>1.645991</td>
      <td>1.474050</td>
      <td>0.508635</td>
      <td>228.94006</td>
      <td>2.500000</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
#Quick plotting a week for last 'minute check'
plot_channels(final.iloc[0:7*24*60,:])
```


![png](/assets/2019-07-30-Sunlab/output_49_0.png)


## Linear regression - the baseline model

Establish a baseline model using a simple linear regression


```python
from sklearn.linear_model import LinearRegression
from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split

#Create a linear regration evaluation function
def eval_linearregression (full_dataset, features, label, train_test_split_ratio = 0.2, shuffle = True):
    #Split the dataset into train and test (with the split ration) and between features (X) and label or variable to forecast (y)
    X_train, X_test, y_train, y_test = train_test_split(full_dataset[features], full_dataset[label], test_size= train_test_split_ratio, random_state = 0 , shuffle = shuffle)
    # Create linear regression object
    model = linear_model.LinearRegression(fit_intercept=False, n_jobs=-1)
    # Train the model using the training sets
    model.fit(X_train, y_train)
    # Make predictions using the testing set
    yhat = model.predict(X_test)
    # The coefficients
    #print('Coefficients: \n', model.coef_, '\n', model.intercept_)
    # The mean squared error
    #print("Mean squared error: %.2f" % mean_squared_error(y_test, yhat))
    # Explained variance score: 1 is perfect prediction
    test_r2_score = r2_score(y_test, yhat)
    yhat = model.predict(X_train)
    train_r2_score = r2_score(y_train, yhat)
    #print('Train R2 score: %.2f, Train R2 score: %.2f' % (train_r2_score, test_r2_score))
    return model, features, test_r2_score, train_r2_score

```


```python
#use all variables and estabilish baseline errors
#variable to forecast
label = ['B_Optimal - Power DC [W]']
#remaining features
features = final.columns.difference(label)

baseline, _, test_r2_score, train_r2_score= eval_linearregression(final, features, label)
print('R2 >> Train : %.4f, Test: %.4f' % (train_r2_score, test_r2_score))

```

    R2 >> Train : 0.7459, Test: 0.7470
    

We have establish an **baseline R2 score of 0.75**

Let's use the baseline model to forecast the 1st month of 2014


```python
#Prepare a funtion to plot and compare (xy) the forecast and real
def plot_compare_line_xy(forecast, real, title):
    
    r2 = round(r2_score(real, forecast),3)
    
    pyplot.figure(figsize=(15,10))
    #line plot
    pyplot.subplot(2,1,1)
    pyplot.plot(real, label='Real')
    pyplot.plot(forecast, label='Forecast')
    pyplot.xlabel('Steps'); pyplot.ylabel('Real'); 
    pyplot.grid(); pyplot.legend()
    #xy plot
    pyplot.subplot(2,1,2)
    pyplot.scatter(real, forecast, label='R$^2$: '+ str(r2))
    pyplot.xlabel('Real'); pyplot.ylabel('Forecast')
    pyplot.grid(); pyplot.legend()
    #plot grooming
    pyplot.suptitle(title, y=1.01)
    pyplot.tight_layout()
    pyplot.show()
```


```python
#forecast 1st month 2014
baseline_forecast = baseline.predict(final.iloc[0:31*24*60][features])
#plot charts 
real = final.iloc[0:31*24*60][label].values

plot_compare_line_xy(baseline_forecast, real, 'January-2014 PV generation forecast with linear regression model (baseline)')
```


![png](/assets/2019-07-30-Sunlab/output_55_0.png)


## Random forest model

(An intro on random forest...)


```python
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

def eval_randomforest(df, features, label, n_estimators):
    
    #print('Features: ', features)
    #print('Label: ', label)
    
    #scale dataset ?
    #...
    
    #spliting the final data set to 
    X_train, X_test, y_train, y_test = train_test_split(df[features], df[label], test_size = 0.30, random_state = 0, shuffle = True)
    
    #array shape info
    print('Shapes >> Train: ', X_train.shape, y_train.shape, 'Test:', X_test.shape, y_test.shape)
    
    #establish and fit regressor
    model = RandomForestRegressor(n_estimators = n_estimators, random_state = 0, verbose=1, n_jobs=-1)
    model.fit(X_train, y_train)
    
    #save to disk
    #...
    
    #Results
    train_predictions = model.predict(X_train)
    #errors = abs(train_predictions - y_train)
    score_train = r2_score(y_train, train_predictions)
    #print('Train >> Mean Absolute Error: ', round(np.mean(errors), 2), 'W, R2: %.2f' % (score_train))
    
    #Test errors
    test_predictions = model.predict(X_test)
    #errors = abs(test_predictions - y_test)
    score_test = r2_score(y_test, test_predictions)
    #print('Test >> Mean Absolute Error: ', round(np.mean(errors), 2), 'W, R2: %.2f' % (score_test))
    
    print('R2 >> Train: ', round(score_train, 3), ', Test: ', round(score_test, 3))
    
    return model, score_train, score_test
```


```python
#using the same features as the baseline model
rf_model, score_train, score_test = eval_randomforest(final, features, label, n_estimators = 20)
```

    Shapes >> Train:  (1040838, 6) (1040838, 1) Test: (446074, 6) (446074, 1)
    

    [Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 4 concurrent workers.
    [Parallel(n_jobs=-1)]: Done  20 out of  20 | elapsed:  1.9min finished
    [Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.
    [Parallel(n_jobs=4)]: Done  20 out of  20 | elapsed:    5.9s finished
    [Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.
    

    R2 >> Train:  0.982 , Test:  0.891
    

    [Parallel(n_jobs=4)]: Done  20 out of  20 | elapsed:    2.2s finished
    

The R2 score went up to **0.88** that represents an interessting incresase from our baseline model (R2 = 0.75)

Let's check the variable importance


```python
#Variable importance
feature_list = list(features)
importances = list(rf_model.feature_importances_)
feature_importances = [ [feature, round(importance, 2)] for feature, importance in zip(feature_list, importances)]
feature_importances = sorted(feature_importances, key = lambda x: x[1], reverse = True)
print('Variable importances:')
[print('Variable: {:30} Importance: {}'.format(*pair)) for pair in feature_importances];
```

    Variable importances:
    Variable: Ultraviolet [W/m2]             Importance: 0.62
    Variable: Global Radiation [W/m2]        Importance: 0.2
    Variable: Ambient Temperature [ºC]       Importance: 0.07
    Variable: Diffuse Radiation [W/m2]       Importance: 0.05
    Variable: Wind Direction [º]             Importance: 0.04
    Variable: Wind Velocity [m/s]            Importance: 0.03
    

In line with the correlation UV e Global Radiation acount for >80% of the importance. 

Also, is interesting to see that UV is more relevante than a Global Radiation, despite UV a Global Radiation having aproximatly the same correlation (0.86).

Let's just check the performance for the 1st month of 2014 forecast


```python
#forecast 1st month 2014
rf_forecast = rf_model.predict(final.iloc[0:7*24*60][features])
real = final.iloc[0:7*24*60][label].values
plot_compare_line_xy(rf_forecast, real, 'January-2014 PV generation forecast with Random Forest Model')
```

    [Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.
    [Parallel(n_jobs=4)]: Done  20 out of  20 | elapsed:    0.6s finished
    


![png](/assets/2019-07-30-Sunlab/output_62_1.png)


Once again, an interesiting increase in acurracy as the R2 score achives 0.73 (vs 0.62 with baseline model)

## Conclusion
(tbc)

